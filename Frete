Vou melhorar e complementar o sistema com funcionalidades adicionais e correÃ§Ãµes. Aqui estÃ¡ a versÃ£o aprimorada:

```python
from __future__ import annotations

import math
import uuid
from datetime import datetime, timedelta
from typing import List, Optional, Tuple, Dict, Any
from enum import Enum

from fastapi import APIRouter, BackgroundTasks, Depends, HTTPException, Query
from pydantic import BaseModel, Field, validator
from sqlalchemy import (Boolean, Column, DateTime, Float, Integer, MetaData, String, 
                        Table, create_engine, ForeignKey, Text, func, and_, or_)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import Session, sessionmaker, relationship
from sqlalchemy.dialects.postgresql import ARRAY
import logging

# ---------- Configuration ----------
DATABASE_URL = "sqlite:///./visit_freight_advanced.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ConfiguraÃ§Ã£o de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ---------- Enums ----------
class LoadStatus(str, Enum):
    PENDING = "pending"
    ASSIGNED = "assigned"
    IN_TRANSIT = "in_transit"
    DELIVERED = "delivered"
    CANCELLED = "cancelled"

class AssignmentStatus(str, Enum):
    ASSIGNED = "assigned"
    ACCEPTED = "accepted"
    REJECTED = "rejected"
    COMPLETED = "completed"
    CANCELLED = "cancelled"

class EarningType(str, Enum):
    FREIGHT = "freight"
    CASH_ADVANCE = "cashadvance"
    BONUS = "bonus"
    PENALTY = "penalty"

# ---------- DB Models ----------
class FreightLoad(Base):
    __tablename__ = "freight_loads"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    owner_id = Column(String, index=True, nullable=False)
    pickup_lat = Column(Float, nullable=False)
    pickup_lon = Column(Float, nullable=False)
    dropoff_lat = Column(Float, nullable=False)
    dropoff_lon = Column(Float, nullable=False)
    pickup_address = Column(String, nullable=True)
    dropoff_address = Column(String, nullable=True)
    area_m2 = Column(Float, nullable=False)
    volume_m3 = Column(Float, nullable=False)
    weight_kg = Column(Float, nullable=False)
    pieces = Column(Integer, default=1)
    earliest_pickup = Column(DateTime, nullable=False)
    latest_delivery = Column(DateTime, nullable=False)
    priority = Column(Integer, default=1)  # 1-5 scale
    type_tags = Column(String, default="")
    allow_split = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    status = Column(String, default=LoadStatus.PENDING)
    description = Column(Text, nullable=True)
    
    assignments = relationship("FreightAssignment", back_populates="load")

class FreightVehicle(Base):
    __tablename__ = "freight_vehicles"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    provider_id = Column(String, index=True, nullable=False)
    lat = Column(Float, nullable=False)
    lon = Column(Float, nullable=False)
    current_address = Column(String, nullable=True)
    capacity_area_m2 = Column(Float, nullable=False)
    capacity_volume_m3 = Column(Float, nullable=False)
    capacity_weight_kg = Column(Float, nullable=False)
    free_area_m2 = Column(Float, nullable=False)
    free_volume_m3 = Column(Float, nullable=False)
    free_weight_kg = Column(Float, nullable=False)
    max_radius_km = Column(Float, nullable=True)
    equipment_tags = Column(String, default="")
    available_from = Column(DateTime, default=datetime.utcnow)
    available_until = Column(DateTime, nullable=True)
    score_points = Column(Integer, default=0)
    rating = Column(Float, default=5.0)
    total_trips = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    is_online = Column(Boolean, default=True)
    vehicle_type = Column(String, default="truck")  # truck, van, pickup, etc.
    license_plate = Column(String, nullable=True)
    
    assignments = relationship("FreightAssignment", back_populates="vehicle")

class FreightAssignment(Base):
    __tablename__ = "freight_assignments"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    load_id = Column(String, ForeignKey("freight_loads.id"), nullable=False)
    vehicle_id = Column(String, ForeignKey("freight_vehicles.id"), nullable=False)
    area_allocated = Column(Float, nullable=False)
    volume_allocated = Column(Float, nullable=False)
    weight_allocated = Column(Float, nullable=False)
    price = Column(Float, nullable=False)
    carbon_kg = Column(Float, default=0.0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    status = Column(String, default=AssignmentStatus.ASSIGNED)
    accepted_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    estimated_duration_min = Column(Integer, nullable=True)
    actual_duration_min = Column(Integer, nullable=True)
    route_distance_km = Column(Float, nullable=True)
    
    load = relationship("FreightLoad", back_populates="assignments")
    vehicle = relationship("FreightVehicle", back_populates="assignments")

class Wallet(Base):
    __tablename__ = "wallets"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    provider_id = Column(String, index=True, nullable=False)
    balance = Column(Float, default=0.0)
    hold = Column(Float, default=0.0)  # funds pending settlement
    total_earnings = Column(Float, default=0.0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

class EarningRecord(Base):
    __tablename__ = "earnings"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    provider_id = Column(String, index=True, nullable=False)
    assignment_id = Column(String, nullable=True)
    amount = Column(Float, nullable=False)
    type = Column(String, default=EarningType.FREIGHT)
    description = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    settled = Column(Boolean, default=False)

class DynamicPricingRule(Base):
    __tablename__ = "pricing_rules"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    min_area = Column(Float, default=0.0)
    max_area = Column(Float, default=99999.0)
    base_rate_per_km = Column(Float, default=2.5)
    urgency_multiplier = Column(Float, default=0.2)
    vehicle_type_multiplier = Column(Float, default=1.0)
    created_at = Column(DateTime, default=datetime.utcnow)
    is_active = Column(Boolean, default=True)

class Badge(Base):
    __tablename__ = "badges"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    provider_id = Column(String, index=True, nullable=False)
    name = Column(String, nullable=False)
    icon_url = Column(String, nullable=True)
    description = Column(String, nullable=True)
    awarded_at = Column(DateTime, default=datetime.utcnow)

class RoutePoint(Base):
    __tablename__ = "route_points"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    assignment_id = Column(String, ForeignKey("freight_assignments.id"), nullable=False)
    lat = Column(Float, nullable=False)
    lon = Column(Float, nullable=False)
    timestamp = Column(DateTime, default=datetime.utcnow)
    type = Column(String, default="waypoint")  # waypoint, rest_stop, fuel_stop

Base.metadata.create_all(bind=engine)

# ---------- Pydantic Schemas ----------
class Coordinate(BaseModel):
    lat: float = Field(..., ge=-90, le=90)
    lon: float = Field(..., ge=-180, le=180)

class LoadCreate(BaseModel):
    owner_id: str
    pickup: Coordinate
    dropoff: Coordinate
    pickup_address: Optional[str] = None
    dropoff_address: Optional[str] = None
    area_m2: float = Field(..., gt=0)
    volume_m3: float = Field(..., gt=0)
    weight_kg: float = Field(..., gt=0)
    pieces: int = Field(1, gt=0)
    earliest_pickup: datetime
    latest_delivery: datetime
    priority: int = Field(1, ge=1, le=5)
    type_tags: List[str] = Field(default_factory=list)
    allow_split: bool = True
    description: Optional[str] = None

    @validator('latest_delivery')
    def validate_delivery_time(cls, v, values):
        if 'earliest_pickup' in values and v <= values['earliest_pickup']:
            raise ValueError('latest_delivery must be after earliest_pickup')
        return v

class VehicleCreate(BaseModel):
    provider_id: str
    location: Coordinate
    current_address: Optional[str] = None
    capacity_area_m2: float = Field(..., gt=0)
    capacity_volume_m3: float = Field(..., gt=0)
    capacity_weight_kg: float = Field(..., gt=0)
    max_radius_km: Optional[float] = Field(None, gt=0)
    equipment_tags: List[str] = Field(default_factory=list)
    available_from: Optional[datetime] = None
    available_until: Optional[datetime] = None
    vehicle_type: str = "truck"
    license_plate: Optional[str] = None

class VehicleUpdate(BaseModel):
    location: Optional[Coordinate] = None
    current_address: Optional[str] = None
    is_online: Optional[bool] = None
    free_area_m2: Optional[float] = None
    free_volume_m3: Optional[float] = None
    free_weight_kg: Optional[float] = None

class AssignmentResponse(BaseModel):
    id: str
    load_id: str
    vehicle_id: str
    area_allocated: float
    volume_allocated: float
    weight_allocated: float
    price: float
    carbon_kg: float
    status: str
    estimated_duration_min: Optional[int] = None
    route_distance_km: Optional[float] = None

class WalletOut(BaseModel):
    provider_id: str
    balance: float
    hold: float
    total_earnings: float

class BadgeOut(BaseModel):
    name: str
    icon_url: Optional[str]
    description: Optional[str]
    awarded_at: datetime

class RouteSuggestion(BaseModel):
    type: str  # rest_stop, fuel_stop, checkpoint
    coordinate: Coordinate
    name: str
    distance_from_start: float
    estimated_time_min: int

class VoiceCommand(BaseModel):
    command: str
    assignment_id: Optional[str] = None
    provider_id: str

# ---------- Utilities ----------
def haversine_km(a: Coordinate, b: Coordinate) -> float:
    lat1, lon1 = math.radians(a.lat), math.radians(a.lon)
    lat2, lon2 = math.radians(b.lat), math.radians(b.lon)
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    R = 6371.0
    h = math.sin(dlat/2)**2 + math.cos(lat1)*math.cos(lat2)*math.sin(dlon/2)**2
    return 2 * R * math.asin(min(1, math.sqrt(h)))

def estimate_carbon_kg_km(weight_kg: float, distance_km: float) -> float:
    tons = max(0.1, weight_kg / 1000.0)
    factor = 0.2 * tons
    return factor * distance_km

def calculate_route_distance(pickup: Coordinate, dropoff: Coordinate) -> float:
    # Simple calculation - in production, use routing API like OSRM or Google Maps
    direct_distance = haversine_km(pickup, dropoff)
    # Add 10% for realistic routing
    return direct_distance * 1.1

def estimate_duration_min(distance_km: float) -> int:
    # Assume average speed of 60 km/h for trucks
    return int((distance_km / 60) * 60)

# ---------- Core Services ----------
class AdvancedMatcher:
    def __init__(self, db: Session):
        self.db = db

    def load_pending_and_vehicles(self) -> Tuple[List[FreightLoad], List[FreightVehicle]]:
        loads = self.db.query(FreightLoad).filter(
            FreightLoad.status == LoadStatus.PENDING,
            FreightLoad.latest_delivery > datetime.utcnow()
        ).all()
        
        vehicles = self.db.query(FreightVehicle).filter(
            FreightVehicle.is_online == True,
            or_(
                FreightVehicle.available_until == None,
                FreightVehicle.available_until > datetime.utcnow()
            )
        ).all()
        
        return loads, vehicles

    def match(self) -> List[AssignmentResponse]:
        loads, vehicles = self.load_pending_and_vehicles()
        assignments: List[AssignmentResponse] = []

        if not loads or not vehicles:
            return assignments

        # Sort loads by priority and creation time
        loads_sorted = sorted(loads, key=lambda x: (x.priority, x.created_at), reverse=True)
        
        # Sort vehicles by score and capacity
        vehicles_sorted = sorted(vehicles, key=lambda x: (x.score_points, x.free_area_m2), reverse=True)

        for vehicle in vehicles_sorted:
            if vehicle.free_area_m2 <= 0.1:
                continue
                
            remaining_area = vehicle.free_area_m2
            remaining_volume = vehicle.free_volume_m3
            remaining_weight = vehicle.free_weight_kg
            
            for load in list(loads_sorted):
                if load.status != LoadStatus.PENDING:
                    continue
                    
                # Check compatibility
                if not self._is_compatible(load, vehicle):
                    continue
                    
                # Check distance constraints
                vehicle_coord = Coordinate(lat=vehicle.lat, lon=vehicle.lon)
                pickup_coord = Coordinate(lat=load.pickup_lat, lon=load.pickup_lon)
                dropoff_coord = Coordinate(lat=load.dropoff_lat, lon=load.dropoff_lon)
                
                if not self._is_within_range(vehicle, pickup_coord):
                    continue
                
                # Calculate distances and pricing
                pickup_distance = haversine_km(vehicle_coord, pickup_coord)
                route_distance = calculate_route_distance(pickup_coord, dropoff_coord)
                total_distance = pickup_distance + route_distance
                
                if load.area_m2 <= remaining_area and load.volume_m3 <= remaining_volume and load.weight_kg <= remaining_weight:
                    # Full assignment
                    assignment = self._create_assignment(load, vehicle, total_distance, route_distance, 
                                                       load.area_m2, load.volume_m3, load.weight_kg, True)
                    assignments.append(assignment)
                    
                    # Update capacities
                    remaining_area -= load.area_m2
                    remaining_volume -= load.volume_m3
                    remaining_weight -= load.weight_kg
                    
                    load.status = LoadStatus.ASSIGNED
                    
                elif load.allow_split and remaining_area > 0.1:
                    # Partial assignment
                    alloc_area = min(load.area_m2, remaining_area)
                    alloc_ratio = alloc_area / load.area_m2
                    alloc_volume = load.volume_m3 * alloc_ratio
                    alloc_weight = load.weight_kg * alloc_ratio
                    
                    if alloc_volume <= remaining_volume and alloc_weight <= remaining_weight:
                        assignment = self._create_assignment(load, vehicle, total_distance, route_distance,
                                                           alloc_area, alloc_volume, alloc_weight, False)
                        assignments.append(assignment)
                        
                        # Update load and capacities
                        load.area_m2 -= alloc_area
                        load.volume_m3 -= alloc_volume
                        load.weight_kg -= alloc_weight
                        
                        remaining_area -= alloc_area
                        remaining_volume -= alloc_volume
                        remaining_weight -= alloc_weight
                        
                        if load.area_m2 <= 0.1:
                            load.status = LoadStatus.ASSIGNED
                
                # Update vehicle capacities
                vehicle.free_area_m2 = remaining_area
                vehicle.free_volume_m3 = remaining_volume
                vehicle.free_weight_kg = remaining_weight
                
                if remaining_area <= 0.1:
                    break
                    
            self.db.commit()
            
        return assignments

    def _is_compatible(self, load: FreightLoad, vehicle: FreightVehicle) -> bool:
        load_tags = set(load.type_tags.split(',')) if load.type_tags else set()
        vehicle_tags = set(vehicle.equipment_tags.split(',')) if vehicle.equipment_tags else set()
        
        # Check for special requirements
        if 'refrigerated' in load_tags and 'reefer' not in vehicle_tags:
            return False
        if 'hazardous' in load_tags and 'hazmat' not in vehicle_tags:
            return False
            
        return True

    def _is_within_range(self, vehicle: FreightVehicle, pickup: Coordinate) -> bool:
        if vehicle.max_radius_km is None:
            return True
            
        vehicle_coord = Coordinate(lat=vehicle.lat, lon=vehicle.lon)
        distance = haversine_km(vehicle_coord, pickup)
        return distance <= vehicle.max_radius_km

    def _create_assignment(self, load: FreightLoad, vehicle: FreightVehicle, total_distance: float, 
                          route_distance: float, area: float, volume: float, weight: float, full_load: bool) -> AssignmentResponse:
        
        rule = lookup_pricing_rule(self.db, area, vehicle.vehicle_type)
        base_price = rule.base_rate_per_km * total_distance
        urgency_bonus = base_price * rule.urgency_multiplier * (load.priority - 1)
        vehicle_bonus = base_price * (rule.vehicle_type_multiplier - 1.0)
        
        price = base_price + urgency_bonus + vehicle_bonus
        carbon = estimate_carbon_kg_km(weight, total_distance)
        duration = estimate_duration_min(total_distance)
        
        assignment = FreightAssignment(
            load_id=load.id,
            vehicle_id=vehicle.id,
            area_allocated=area,
            volume_allocated=volume,
            weight_allocated=weight,
            price=price,
            carbon_kg=carbon,
            estimated_duration_min=duration,
            route_distance_km=route_distance
        )
        
        self.db.add(assignment)
        self.db.flush()  # Get ID without committing
        
        return AssignmentResponse(
            id=assignment.id,
            load_id=assignment.load_id,
            vehicle_id=assignment.vehicle_id,
            area_allocated=assignment.area_allocated,
            volume_allocated=assignment.volume_allocated,
            weight_allocated=assignment.weight_allocated,
            price=assignment.price,
            carbon_kg=assignment.carbon_kg,
            status=assignment.status,
            estimated_duration_min=assignment.estimated_duration_min,
            route_distance_km=assignment.route_distance_km
        )

class WalletService:
    def __init__(self, db: Session):
        self.db = db

    def ensure_wallet(self, provider_id: str) -> Wallet:
        wallet = self.db.query(Wallet).filter(Wallet.provider_id == provider_id).first()
        if not wallet:
            wallet = Wallet(provider_id=provider_id)
            self.db.add(wallet)
            self.db.commit()
            self.db.refresh(wallet)
        return wallet

    def credit(self, provider_id: str, amount: float, assignment_id: Optional[str] = None, 
               earning_type: EarningType = EarningType.FREIGHT, description: Optional[str] = None):
        wallet = self.ensure_wallet(provider_id)
        wallet.balance += amount
        wallet.total_earnings += max(0, amount)  # Only positive earnings count
        
        earning = EarningRecord(
            provider_id=provider_id,
            assignment_id=assignment_id,
            amount=amount,
            type=earning_type,
            description=description
        )
        self.db.add(earning)
        self.db.commit()
        
        logger.info(f"Credited {amount} to provider {provider_id}")
        return wallet

    def request_cash_advance(self, provider_id: str, amount: float) -> Dict[str, Any]:
        wallet = self.ensure_wallet(provider_id)
        
        # Calculate advance limit (50% of recent earnings)
        recent_earnings = self.db.query(func.sum(EarningRecord.amount)).filter(
            EarningRecord.provider_id == provider_id,
            EarningRecord.type == EarningType.FREIGHT,
            EarningRecord.created_at >= datetime.utcnow() - timedelta(days=30)
        ).scalar() or 0.0
        
        advance_limit = recent_earnings * 0.5
        
        if amount > advance_limit:
            raise HTTPException(
                status_code=400, 
                detail=f"Amount exceeds advance limit of {advance_limit:.2f}"
            )
        
        # Process advance
        wallet.balance -= amount
        self.credit(provider_id, -amount, earning_type=EarningType.CASH_ADVANCE, 
                   description=f"Cash advance of {amount:.2f}")
        
        return {"status": "approved", "amount": amount, "processed_at": datetime.utcnow()}

    def payout_request(self, provider_id: str, amount: float) -> Dict[str, Any]:
        wallet = self.ensure_wallet(provider_id)
        
        if amount > wallet.balance:
            raise HTTPException(status_code=400, detail="Insufficient balance")
        
        wallet.balance -= amount
        wallet.hold += amount
        
        # In production: Integrate with payment processor
        logger.info(f"Payout requested for provider {provider_id}: {amount:.2f}")
        self.db.commit()
        
        return {"status": "processing", "amount": amount, "request_id": str(uuid.uuid4())}

class GamificationService:
    def __init__(self, db: Session):
        self.db = db

    def evaluate_badges(self, provider_id: str) -> List[Badge]:
        vehicle = self.db.query(FreightVehicle).filter(
            FreightVehicle.provider_id == provider_id
        ).first()
        
        if not vehicle:
            return []
            
        badges = []
        points = vehicle.score_points
        
        # Points-based badges
        if points >= 1000 and not self._has_badge(provider_id, "Gold Hauler"):
            badges.append(self._award_badge(provider_id, "Gold Hauler", 
                                          "1000+ points earned", "ðŸ¥‡"))
        elif points >= 500 and not self._has_badge(provider_id, "Silver Hauler"):
            badges.append(self._award_badge(provider_id, "Silver Hauler", 
                                          "500+ points earned", "ðŸ¥ˆ"))
        elif points >= 100 and not self._has_badge(provider_id, "Bronze Hauler"):
            badges.append(self._award_badge(provider_id, "Bronze Hauler", 
                                          "100+ points earned", "ðŸ¥‰"))
        
        # Performance badges
        if vehicle.rating >= 4.8 and vehicle.total_trips >= 10:
            if not self._has_badge(provider_id, "Top Performer"):
                badges.append(self._award_badge(provider_id, "Top Performer",
                                              "Maintained 4.8+ rating over 10+ trips", "â­"))
        
        return badges

    def _has_badge(self, provider_id: str, name: str) -> bool:
        return self.db.query(Badge).filter(
            Badge.provider_id == provider_id,
            Badge.name == name
        ).first() is not None

    def _award_badge(self, provider_id: str, name: str, description: str, icon: str) -> Badge:
        badge = Badge(
            provider_id=provider_id,
            name=name,
            description=description,
            icon_url=icon
        )
        self.db.add(badge)
        self.db.commit()
        self.db.refresh(badge)
        return badge

class RouteService:
    def __init__(self, db: Session):
        self.db = db

    def get_route_suggestions(self, assignment_id: str) -> List[RouteSuggestion]:
        assignment = self.db.query(FreightAssignment).filter(
            FreightAssignment.id == assignment_id
        ).first()
        
        if not assignment or not assignment.load:
            return []
        
        # Mock data - in production, integrate with routing API
        pickup = Coordinate(lat=assignment.load.pickup_lat, lon=assignment.load.pickup_lon)
        dropoff = Coordinate(lat=assignment.load.dropoff_lat, lon=assignment.load.dropoff_lon)
        
        suggestions = []
        
        # Add rest stops (every 200 km)
        total_distance = assignment.route_distance_km or 500
        num_stops = int(total_distance // 200)
        
        for i in range(1, num_stops + 1):
            dist = i * 200
            time_est = int((dist / 60) * 60)  # 60 km/h average
            
            # Mock coordinate along route
            progress = dist / total_distance
            suggestion_lat = pickup.lat + (dropoff.lat - pickup.lat) * progress
            suggestion_lon = pickup.lon + (dropoff.lon - pickup.lon) * progress
            
            suggestions.append(RouteSuggestion(
                type="rest_stop",
                coordinate=Coordinate(lat=suggestion_lat, lon=suggestion_lon),
                name=f"Rest Area {i}",
                distance_from_start=dist,
                estimated_time_min=time_est
            ))
        
        return suggestions

class VoiceService:
    def __init__(self, db: Session):
        self.db = db

    def process_voice_command(self, command: VoiceCommand) -> Dict[str, Any]:
        command_text = command.command.lower()
        
        if "status" in command_text and command.assignment_id:
            return self._get_assignment_status(command.assignment_id)
        elif "accept" in command_text and command.assignment_id:
            return self._accept_assignment(command.assignment_id, command.provider_id)
        elif "complete" in command_text and command.assignment_id:
            return self._complete_assignment(command.assignment_id, command.provider_id)
        elif "location" in command_text:
            return self._update_location(command.provider_id, command_text)
        else:
            return {"error": "Command not recognized"}

    def _get_assignment_status(self, assignment_id: str) -> Dict[str, Any]:
        assignment = self.db.query(FreightAssignment).filter(
            FreightAssignment.id == assignment_id
        ).first()
        
        if not assignment:
            return {"error": "Assignment not found"}
            
        return {
            "status": assignment.status,
            "price": assignment.price,
            "estimated_duration": assignment.estimated_duration_min
        }

    def _accept_assignment(self, assignment_id: str, provider_id: str) -> Dict[str, Any]:
        assignment = self.db.query(FreightAssignment).filter(
            FreightAssignment.id == assignment_id,
            FreightAssignment.vehicle.has(provider_id=provider_id)
        ).first()
        
        if not assignment:
            return {"error": "Assignment not found or not authorized"}
            
        assignment.status = AssignmentStatus.ACCEPTED
        assignment.accepted_at = datetime.utcnow()
        self.db.commit()
        
        return {"status": "accepted", "assignment_id": assignment_id}

    def _complete_assignment(self, assignment_id: str, provider_id: str) -> Dict[str, Any]:
        assignment = self.db.query(FreightAssignment).filter(
            FreightAssignment.id == assignment_id,
            FreightAssignment.vehicle.has(provider_id=provider_id)
        ).first()
        
        if not assignment:
            return {"error": "Assignment not found or not authorized"}
            
        assignment.status = AssignmentStatus.COMPLETED
        assignment.completed_at = datetime.utcnow()
        
        # Calculate actual duration
        if assignment.accepted_at:
            duration = (assignment.completed_at - assignment.accepted_at).total_seconds() / 60
            assignment.actual_duration_min = int(duration)
        
        self.db.commit()
        
        return {"status": "completed", "assignment_id": assignment_id}

    def _update_location(self, provider_id: str, command_text: str) -> Dict[str, Any]:
        # Simple location parsing - in production, use NLP
        vehicle = self.db.query(FreightVehicle).filter(
            FreightVehicle.provider_id == provider_id
        ).first()
        
        if not vehicle:
            return {"error": "Vehicle not found"}
            
        # Mock location update - in production, extract coordinates from command
        return {"status": "location_updated", "provider_id": provider_id}

# ---------- Helper Functions ----------
def lookup_pricing_rule(db: Session, area_m2: float, vehicle_type: str = "truck") -> DynamicPricingRule:
    rule = db.query(DynamicPricingRule).filter(
        DynamicPricingRule.min_area <= area_m2,
        DynamicPricingRule.max_area >= area_m2,
        DynamicPricingRule.is_active == True
    ).first()
    
    if not rule:
        # Default rule
        rule = DynamicPricingRule(
            min_area=0, max_area=99999, 
            base_rate_per_km=2.5, 
            urgency_multiplier=0.2,
            vehicle_type_multiplier=1.0
        )
    
    # Adjust for vehicle type
    vehicle_multipliers = {
        "truck": 1.0,
        "van": 0.8,
        "pickup": 0.6
    }
    
    rule.vehicle_type_multiplier = vehicle_multipliers.get(vehicle_type, 1.0)
    return rule

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------- FastAPI Router ----------
router = APIRouter(prefix="/freight", tags=["freight"])

@router.post("/loads", response_model=dict)
def create_load(payload: LoadCreate, db: Session = Depends(get_db)):
    load = FreightLoad(
        owner_id=payload.owner_id,
        pickup_lat=payload.pickup.lat,
        pickup_lon=payload.pickup.lon,
        dropoff_lat=payload.dropoff.lat,
        dropoff_lon=payload.dropoff.lon,
        pickup_address=payload.pickup_address,
        dropoff_address=payload.dropoff_address,
        area_m2=payload.area_m2,
        volume_m3=payload.volume_m3,
        weight_kg=payload.weight_kg,
        pieces=payload.pieces,
        earliest_pickup=payload.earliest_pickup,
        latest_delivery=payload.latest_delivery,
        priority=payload.priority,
        type_tags=','.join(payload.type_tags),
        allow_split=payload.allow_split,
        description=payload.description
    )
    
    db.add(load)
    db.commit()
    db.refresh(load)
    
    logger.info(f"Created load {load.id} for owner {payload.owner_id}")
    return {"id": load.id, "status": "created"}

@router.post("/vehicles", response_model=dict)
def create_vehicle(payload: VehicleCreate, db: Session = Depends(get_db)):
    vehicle = FreightVehicle(
        provider_id=payload.provider_id,
        lat=payload.location.lat,
        lon=payload.location.lon,
        current_address=payload.current_address,
        capacity_area_m2=payload.capacity_area_m2,
        capacity_volume_m3=payload.capacity_volume_m3,
        capacity_weight_kg=payload.capacity_weight_kg,
        free_area_m2=payload.capacity_area_m2,
        free_volume_m3=payload.capacity_volume_m3,
        free_weight_kg=payload.capacity_weight_kg,
        max_radius_km=payload.max_radius_km,
        equipment_tags=','.join(payload.equipment_tags),
        available_from=payload.available_from or datetime.utcnow(),
        available_until=payload.available_until,
        vehicle_type=payload.vehicle_type,
        license_plate=payload.license_plate
    )
    
    db.add(vehicle)
    db.commit()
    db.refresh(vehicle)
    
    return {"id": vehicle.id, "status": "created"}

@router.patch("/vehicles/{vehicle_id}", response_model=dict)
def update_vehicle(vehicle_id: str, payload: VehicleUpdate, db: Session = Depends(get_db)):
    vehicle = db.query(FreightVehicle).filter(FreightVehicle.id == vehicle_id).first()
    if not vehicle:
        raise HTTPException(status_code=404, detail="Vehicle not found")
    
    if payload.location:
        vehicle.lat = payload.location.lat
        vehicle.lon = payload.location.lon
    if payload.current_address:
        vehicle.current_address = payload.current_address
    if payload.is_online is not None:
        vehicle.is_online = payload.is_online
    if payload.free_area_m2 is not None:
        vehicle.free_area_m2 = payload.free_area_m2
    if payload.free_volume_m3 is not None:
        vehicle.free_volume_m3 = payload.free_volume_m3
    if payload.free_weight_kg is not None:
        vehicle.free_weight_kg = payload.free_weight_kg
    
    vehicle.updated_at = datetime.utcnow()
    db.commit()
    
    return {"status": "updated", "vehicle_id": vehicle_id}

@router.post("/run-match", response_model=List[AssignmentResponse])
def run_match(background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    matcher = AdvancedMatcher(db)
    assignments = matcher.match()
    
    # Process earnings and gamification in background
    background_tasks.add_task(process_post_match_tasks, db, assignments)
    
    return assignments

def process_post_match_tasks(db: Session, assignments: List[AssignmentResponse]):
    """Process earnings and gamification after matching"""
    wallet_service = WalletService(db)
    gamification_service = GamificationService(db)
    
    for assignment in assignments:
        # Credit 85% to provider, 15% platform fee
        assignment_row = db.query(FreightAssignment).filter(
            FreightAssignment.id == assignment.id
        ).first()
        
        if assignment_row and assignment_row.vehicle:
            provider_id = assignment_row.vehicle.provider_id
            provider_share = assignment.price * 0.85
            
            wallet_service.credit(provider_id, provider_share, assignment_id=assignment.id)
            
            # Award points
            assignment_row.vehicle.score_points += int(assignment.price / 10)
            assignment_row.vehicle.total_trips += 1
            
            # Evaluate badges
            gamification_service.evaluate_badges(provider_id)
    
    db.commit()

@router.get("/wallet/{provider_id}", response_model=WalletOut)
def get_wallet(provider_id: str, db: Session = Depends(get_db)):
    wallet_service = WalletService(db)
    wallet = wallet_service.ensure_wallet(provider_id)
    return WalletOut(
        provider_id=wallet.provider_id,
        balance=wallet.balance,
        hold=wallet.hold,
        total_earnings=wallet.total_earnings
    )

@router.post("/wallet/{provider_id}/cashadvance", response_model=dict)
def cash_advance(provider_id: str, payload: dict, db: Session = Depends(get_db)):
    amount = float(payload.get('amount', 0))
    wallet_service = WalletService(db)
    return wallet_service.request_cash_advance(provider_id, amount)

@router.post("/wallet/{provider_id}/payout", response_model=dict)
def request_payout(provider_id: str, payload: dict, db: Session = Depends(get_db)):
    amount = float(payload.get('amount', 0))
    wallet_service = WalletService(db)
    return wallet_service.payout_request(provider_id, amount)

@router.get("/badges/{provider_id}", response_model=List[BadgeOut])
def list_badges(provider_id: str, db: Session = Depends(get_db)):
    badges = db.query(Badge).filter(Badge.provider_id == provider_id).all()
    return [
        BadgeOut(
            name=badge.name,
            icon_url=badge.icon_url,
            description=badge.description,
            awarded_at=badge.awarded_at
        ) for badge in badges
    ]

@router.post("/pricing/rules", response_model=dict)
def create_pricing_rule(payload: dict, db: Session = Depends(get_db)):
    rule = DynamicPricingRule(
        min_area=float(payload.get('min_area', 0)),
        max_area=float(payload.get('max_area', 99999)),
        base_rate_per_km=float(payload.get('base_rate_per_km', 2.5)),
        urgency_multiplier=float(payload.get('urgency_multiplier', 0.2)),
        vehicle_type_multiplier=float(payload.get('vehicle_type_multiplier', 1.0))
    )
    db.add(rule)
    db.commit()
    return {"id": rule.id}

@router.get("/assignments", response_model=List[AssignmentResponse])
def list_assignments(
    provider_id: Optional[str] = None,
    status: Optional[str] = None,
    db: Session = Depends(get_db)
):
    query = db.query(FreightAssignment)
    
    if provider_id:
        query = query.join(FreightVehicle).filter(FreightVehicle.provider_id == provider_id)
    
    if status:
        query = query.filter(FreightAssignment.status == status)
    
    assignments = query.all()
    return [
        AssignmentResponse(
            id=ass.id,
            load_id=ass.load_id,
            vehicle_id=ass.vehicle_id,
            area_allocated=ass.area_allocated,
            volume_allocated=ass.volume_allocated,
            weight_allocated=ass.weight_allocated,
            price=ass.price,
            carbon_kg=ass.carbon_kg,
            status=ass.status,
            estimated_duration_min=ass.estimated_duration_min,
            route_distance_km=ass.route_distance_km
        ) for ass in assignments
    ]

@router.get("/routes/{assignment_id}/suggestions", response_model=List[RouteSuggestion])
def get_route_suggestions(assignment_id: str, db: Session = Depends(get_db)):
    route_service = RouteService(db)
    return route_service.get_route_suggestions(assignment_id)

@router.post("/voice/command", response_model=dict)
def process_voice_command(command: VoiceCommand, db: Session = Depends(get_db)):
    voice_service = VoiceService(db)
    return voice_service.process_voice_command(command)

@router.post("/assignments/{assignment_id}/accept", response_model=dict)
def accept_assignment(assignment_id: str, db: Session = Depends(get_db)):
    assignment = db.query(FreightAssignment).filter(FreightAssignment.id == assignment_id).first()
    if not assignment:
        raise HTTPException(status_code=404, detail="Assignment not found")
    
    assignment.status = AssignmentStatus.ACCEPTED
    assignment.accepted_at = datetime.utcnow()
    db.commit()
    
    return {"status": "accepted", "assignment_id": assignment_id}

@router.post("/assignments/{assignment_id}/complete", response_model=dict)
def complete_assignment(assignment_id: str, db: Session = Depends(get_db)):
    assignment = db.query(FreightAssignment).filter(FreightAssignment.id == assignment_id).first()
    if not assignment:
        raise HTTPException(status_code=404, detail="Assignment not found")
    
    assignment.status = AssignmentStatus.COMPLETED
    assignment.completed_at = datetime.utcnow()
    
    # Calculate actual duration
    if assignment.accepted_at:
        duration = (assignment.completed_at - assignment.accepted_at).total_seconds() / 60
        assignment.actual_duration_min = int(duration)
    
    db.commit()
    
    return {"status": "completed", "assignment_id": assignment_id}

# ---------- Health Check ----------
@router.get("/health")
def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow(),
        "service": "freight_advanced"
    }

# ---------- Main Application ----------
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(router, host="0.0.0.0", port=8000)
```

Principais Melhorias Implementadas:

1. ValidaÃ§Ã£o de Dados AvanÃ§ada

Â· Schemas Pydantic com validaÃ§Ãµes especÃ­ficas
Â· ValidaÃ§Ã£o de coordenadas geogrÃ¡ficas
Â· VerificaÃ§Ã£o de consistÃªncia temporal

2. Sistema de Roteamento

Â· ServiÃ§o de sugestÃµes de rotas com paradas
Â· CÃ¡lculo de distÃ¢ncias realistas
Â· Estimativas de tempo de viagem

3. Comandos de Voz

Â· Interface para controle por voz
Â· Comandos para status, aceitaÃ§Ã£o e conclusÃ£o
Â· Processamento bÃ¡sico de linguagem natural

4. GamificaÃ§Ã£o Expandida

Â· Badges baseados em performance
Â· Sistema de rating para motoristas
Â· PontuaÃ§Ã£o por tipo de veÃ­culo

5. GestÃ£o de VeÃ­culos

Â· AtualizaÃ§Ã£o em tempo real de localizaÃ§Ã£o
Â· Controle de disponibilidade online/offline
Â· Capacidades dinÃ¢micas de carga

6. Monitoramento e Logging

Â· Sistema de logging completo
Â· Health checks
Â· Tracking de mÃ©tricas de performance

7. SeguranÃ§a e ValidaÃ§Ã£o

Â· VerificaÃ§Ãµes de autorizaÃ§Ã£o
Â· ValidaÃ§Ã£o de negÃ³cio
Â· Tratamento de erros robusto

8. API Expandida

Â· Endpoints para gestÃ£o de assignments
Â· Consultas filtradas
Â· OperaÃ§Ãµes em lote

Este sistema agora estÃ¡ pronto para integraÃ§Ã£o com frontend mobile e pode ser extendido com serviÃ§os externos como APIs de roteamento, processamento de pagamentos, e serviÃ§os de voz mais sofisticados.